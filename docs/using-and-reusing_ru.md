# Использование и повторное использование терминов онтологии

IRI-адреса дают нам все глобально уникальные имена, которые нам нужны. Онтологии дают нам системы стандартизированных имен (и многое другое). Теперь давайте посмотрим, как их использовать.

"Использование" термина ссылочной онтологии OBO означает использование его URI в ваших данных. В каждом семестре должна быть только одна IRI - не придумывайте для нее свое собственное имя, используйте официальное! Я В этом разделе вы узнаете, как найти нужные термины, как оценить их высокое качество и как импортировать их в онтологию приложения для вашего проекта. Мы проиллюстрируем эти методы, создав онтологию приложения для поддержки нашего текущего примера.


## Поиск Терминов Онтологии

Онтологии OBO распространяются свободно, и существует множество различных веб-сайтов, которые вы можете использовать для их поиска. Обычно мы начинаем с поиска подходящей метки, а затем проверяем, соответствуют ли текстовые и логические определения тому, что нам нужно.


### Ontobee

[Ontobee](http://ontobee.org) перечисляет все онтологии OBO и предоставляет полезные инструменты поиска и анализа. Многие проекты OBO используют его в качестве конечной точки для своих PURLS-адресов, если вы нажмете <http://purl.obolibrary.org/obo/OBI_0000070> вы перейдете на страницу Ontobee для термина OBI "анализ". На Ontobee также предоставляет информацию о том, как каждый термин используется в других онтологиях OBO. Страницы октябрьского семестра предоставляют данные RDF/OWL, которые могут быть использованы программным обеспечением. Я постоянно использую Ontobee для поиска терминов OBO, либо в онтологии, которую я знаю, либо во всех проектах OBO.

![Ontobee screenshot](../images/ontobee.png)


### BioPortal

[BioPortal](http://bioportal.bioontology.org) обеспечивает доступ к онтологиям OBO и многим другим онтологиям и терминологиям для биологии и медицины. Если вы не можете найти нужный термин с помощью Ontobee, возможно, вы сможете найти его с помощью биопортала. Если нужный вам термин относится к онтологии, которая не является частью OBO, вы все равно сможете его использовать. См. Раздел ниже, посвященный оценке онтологий для повторного использования.

![BioPortal screenshot](../images/bioportal.png)


### OntoMaton

[[OntoMaton](https://github.com/ISA-tools/OntoMaton#readme) - полезный плагин для [электронных таблиц Google](https://docs.google.com/spreadsheets/). Он использует BioPortal для поиска и автозаполнения терминов в выбранных столбцах вашего листа. Вы также можете настроить его на использование только тех онтологий, которые вы предпочитаете, например, только онтологий OBO. Ограничьтесь минимально возможным набором онтологий, чтобы повысить скорость поиска. Используйте ссылки на термины, чтобы проверить их определения! Когда у меня есть список терминов, которые я хочу сопоставить, часто быстрее всего настроить новую электронную таблицу Google с надстройкой OntoMaton, настроенной в соответствии с онтологиями, которые я хочу использовать.

![OntoMaton screenshot](../images/ontomaton.png)


## Поиск онтологий

В Ontobee перечислены все онтологии OBO и еще несколько, но официальный список находится на домашней странице OBO: <http://obofoundry.org>. В этом списке различаются онтологии "OBO Foundry", которые были проверены на предмет их соответствия принципам OBO Foundry, и онтологии "OBO Library", которые взяли на себя обязательства по принципам, но не были рассмотрены. Для каждой записи есть краткое описание домена, а также ссылки на информационные страницы и файлы онтологий.

Некоторые из принципов и передовых методов OBO основаны на передовых методах разработки программного обеспечения с открытым исходным кодом. Они включают хранение файлов в общедоступных системах управления версиями, которые отслеживают и хранят каждое изменение онтологии. Большинство проектов OBO используют один из этих веб-сайтов для размещения файлов проекта в системе управления версиями:

- [GitHub](https://github.com)
- [SourceForge](http://sourceforge.net)

GitHub построен вокруг [Git](http://www.git-scm.com) распределенная система управления версиями. Sourceforge также поддерживает Git, но чаще вы увидите проект, использующий [Subversion (SVN)](https://subversion.apache.org). Системы контроля версий поначалу могут показаться пугающими, но существуют учебные пособия и приложения, которые облегчают жизнь новичкам. Если вы абсолютный новичок, не волнуйтесь! Вероятно, вы можете делать все, что вам нужно, только с помощью своего веб-браузера.

- На GitHub есть отличный [интерактивный учебник по Git](https://try.github.io)
- Официальная документация Subversion-очень хорошая [book](http://svnbook.red-bean.com), бесплатно онлайн и доступно в копиях мертвого дерева
- Если вас устраивает командная строка, на каждой платформе есть официальные инструменты для SVN и Git
- Если вы уже используете какую-либо интегрированную среду разработки (IDE), очень вероятно, что в нее встроена поддержка Git и SVN
- В Windows большинство людей, похоже, используют [TortoiseSVN](http://tortoisesvn.tigris.org) в качестве графического SVN-клиента
- Для Mac сложнее рекомендовать графический клиент SVN: [Versions](http://versionsapp.com) красиво, но не бесплатно; [svnX](https://code.google.com/p/svnx/) бесплатно, но менее красиво
- [SourceTree](http://www.sourcetreeapp.com) - это мощное бесплатное приложение для работы с Git, доступное для Windows и Mac
- На GitHub также есть бесплатные графические приложения для Git в [Windows](https://windows.github.com) и [Mac](https://mac.github.com)

Проекты OBO используют [Язык веб-онтологий (OWL)](http://www.w3.org/TR/owl2-overview/) и распространяются в файлах OWL. Вы можете использовать веб-сайты Ontobee и BioPortal для просмотра онтологий, но если вы хотите загрузить файл OWL и работать с ним на своем компьютере, вы, вероятно, захотите использовать [Protégé](http://protege.stanford.edu). Protégé является бесплатным, с открытым исходным кодом и кроссплатформенным.


## Оценка онтологий и терминов для повторного использования

Как только вы найдете подходящий термин, вам следует проверить некоторые вещи, прежде чем вы начнете его использовать. Принципы OBO предназначены для охвата всех этих моментов, поэтому при использовании термина из онтологии OBO следует быстро установить все эти флажки. С проектами за пределами сообщества OBO вам придется более тщательно проверять.


### Лицензия

Первый вопрос: могу ли я использовать этот термин в своей онтологии приложения? Это поднимает ряд вопросов об авторском праве.

Онтологии OBO предназначены для совместного использования и должны быть [открытыми](http://obofoundry.github.io/principles/fp-001-open.html), в смысле "с открытым исходным кодом". [Creative Commons CC-by 3.0](https://creativecommons.org/licenses/by/3.0/) лицензия рекомендуется для проектов OBO, хотя есть некоторые различия. Мы ожидаем, что люди, которые используют термины онтологии OBO, будут использовать официальный IRI для этого термина. Мы также ожидаем, что пользователи будут уважать общепринятые стандарты в научном сообществе, отдавая должное разработчикам онтологий за их работу, например, цитируя онтологию в ваших публикациях. (В большинстве онтологий есть "выпускная статья" в журнале, которую вы можете использовать для цитирования. Проверьте веб-сайт онтологии.)


### PURLs

У каждого термина должен быть один официальный IRI, который его идентифицирует, часто называемый "PURL". Когда вы вставляете этот провод в веб-браузер, вы должны быть перенаправлены на полезную веб-страницу или файл. Даже ИРИс для устаревших терминов должен продолжать указывать на что-то полезное. Если термин, который вы хотите использовать, не имеет надежного постоянного идентификатора, то как вы можете быть уверены, что вы и остальные члены сообщества используете один и тот же термин?

Существует принцип OBO для [уникальных идентификаторов](http://obofoundry.github.io/principles/fp-003-uris.html) и [политика идентификации](http://www.obofoundry.org/id-policy.html) с техническими подробностями.


### Метки

Каждый термин должен иметь единый официальный ярлык. У него может быть много синонимов, переводов и альтернативных терминов, но должна быть только одна официальная этикетка. Вероятно, это должно быть на американском английском. В идеале он будет однозначным во всей биологии и биомедицине и позволит избежать двусмысленностей с общими словами на английском языке. Он не должен содержать жаргона или аббревиатур. Принимая все это во внимание, многие ярлыки онтологий длинны и уродливы, но, по крайней мере, они понятны. Вы всегда можете добавить более короткий синоним или альтернативный термин.

Этикетки важны, но определение еще важнее, поэтому не останавливайтесь на чтении этикетки!

Все термины онтологии OBO имеют значение "rdfs:метка". В некоторых онтологиях OBO используется IAO [предпочтительный термин редактора](http://purl.obolibrary.org/obo/IAO_0000111) аннотация для хранения уникальной метки, чтобы "rdfs:метка" могла быть изменена на альтернативный термин, подходящий для конкретных случаев использования. Существуют также [соглашения об именовании](http://obofoundry.github.io/principles/fp-012-naming-conventions.html) для терминов OBO и [метаданных онтологии IAO](https://github.com/information-artifact-ontology/IAO/wiki/OntologyMetadata) страница.

### Текстовые Определения

Есть ли у этого термина текстовое определение?

Существует удивительное количество "онтологий" с терминами, которые имеют IRI-адреса и метки, но вообще не имеют текстовых определений. Для этого есть простая причина: хорошие текстовые определения трудно написать! И когда вы напишете четкое и краткое текстовое определение "X", чаще всего вы обнаружите, что ваши сотрудники говорят: "Мы не так используем "X"". Только когда у вас будет определение, вы действительно сможете начать обсуждать значение термина и прийти к некоторому консенсусу. Без хорошего определения трудно быть уверенным, что все понимают этот термин одинаково.

Для наших текущих целей "аннотация" - это часть данных, прикрепленных к термину, который не имеет логической структуры-мы поговорим о логике всего через секунду. [Метки](http://www.obofoundry.org/wiki/index.php/FP_012_naming_conventions) и [текстовые определения](http://www.obofoundry.org/wiki/index.php/FP_006_textual_definitions) являются наиболее важными аннотациями, но термины еще более ценны, когда в них есть примеры использования, синонимы и альтернативные термины, имена редакторов и примечания редактора. Если термин выглядит многообещающим, прочитайте все его аннотации.


### Логические Определения

Имеет ли этот термин логическое определение?

За некоторыми исключениями, каждый термин должен иметь родительский термин. Онтологии OBO обычно расширяют [Базовую формальную онтологию (BFO)](https://github.com/BFO-ontology/BFO), в котором есть только один термин без родителя: "[сущность](http://purl.obolibrary.org/obo/BFO_0000001)".

Большинство онтологий используют язык веб-онтологии, который предоставляет ряд мощных инструментов для создания логических утверждений о терминах и их взаимосвязях. Четко определенные логические отношения позволяют автоматизировать рассуждения об онтологии и данных, которые ее используют. Чем богаче логические определения, тем больше работы может выполнить рассуждающий, хотя необходимо соблюдать баланс между мощностью и производительностью.

Если термин, который вы хотите использовать, вписывается в верхнюю онтологию и другие отношения, которые вы уже используете, то вы обогащаете сеть данных в онтологии вашего приложения. Если этот термин вам не подходит, то, возможно, вы мало что добавите, используя его. Онтологии OBO стремятся сформировать богатую, взаимосвязанную сеть.


### Статус Термина

Термины имеют "жизненный цикл", начиная с их создания и заканчивая их устареванием. Вы должны проверить статус термина, прежде чем использовать его.

Термины, которые больше не следует использовать, помечены как *устаревшие* с использованием OWL [устаревшие](http://www.w3.org/2002/07/owl#deprecated) аннотация, и причина может быть указана с использованием IAO [имеет причину устаревания](http://purl.obolibrary.org/obo/IAO_0000231) аннотация. Слово "устаревший" обычно добавляется к Метке в качестве дополнительного предупреждения. Устаревший термин не должен *использоваться* для новых данных! Однако лучше всего поддерживать устаревшие термины на неопределенный срок в одном и том же IRI для поддержки старых данных. Если термин, который вы хотите использовать, помечен как устаревший, проверьте аннотации на предмет предпочтительной замены.

Многие термины OBO снабжены комментариями IAO [имеет статус куратора](http://purl.obolibrary.org/obo/IAO_0000114), чтобы указать, где этот термин находится в своем жизненном цикле. Срок годности отмечен [готов к выпуску](http://purl.obolibrary.org/obo/IAO_0000122), и другие статусы указывают, насколько близок срок погашения. Вы должны предпочесть термины со статусом ближе к началу этого списка:

- [готов к выпуску](http://purl.obolibrary.org/obo/IAO_0000122)
- [в ожидании окончательной проверки](http://purl.obolibrary.org/obo/IAO_0000125)
- [метаданные завершены](http://purl.obolibrary.org/obo/IAO_0000120)
- [неполные метаданные](http://purl.obolibrary.org/obo/IAO_0000123)
- [требует обсуждения](http://purl.obolibrary.org/obo/IAO_0000428)
- [организационный термин](http://purl.obolibrary.org/obo/IAO_0000121)
- [должен быть заменен термином внешней онтологии](http://purl.obolibrary.org/obo/IAO_0000423)
- [пример, который в конечном итоге будет удален](http://purl.obolibrary.org/obo/IAO_0000002)
- [необработанный](http://purl.obolibrary.org/obo/IAO_0000124)

Проблемы, которые мешают термину быть "готовым к выпуску", часто объясняются в примечании редактора.

### Сообщество

Кто создал эту онтологию? Когда это было сделано? Была ли она обновлена с момента ее первоначального выпуска? Будет ли он когда-нибудь обновляться снова?

Несколько связанных принципов OBO требуют, чтобы в онтологии было сообщество [пользователей](http://www.obofoundry.org/wiki/index.php/FP_009_users) кто [сотрудничает](http://www.obofoundry.org/wiki/index.php/FP_010_collaboration) в онтологии [какое-либо ответственное лицо, группа или организация](http://www.obofoundry.org/wiki/index.php/FP_011_locus_of_authority), и приверженность постоянному [техническому обслуживанию](http://www.obofoundry.org/wiki/index.php/FP_016_maintenance). Слишком часто я находил онтологию, которая соответствует всем остальным критериям, но она была разработана несколькими авторами для поддержки одного проекта пять лет назад, и с тех пор она не обновлялась. Создать онтологию и поддерживать ее сложно. Создать сообщество и поддерживать его еще сложнее. Но это еще одна вещь, к которой стремятся проекты OBO.


## Термины сопоставления

Мы только что видели, как находить онтологии и термины OBO и как оценивать их качество. Теперь давайте применим это на практике.

Начиная с данных, подобных нашим [data-before.csv](https://github.com/imbok-pro/obo-tutorial/blob/master/examples/data-before.csv) электронная таблица, мой первый шаг обычно заключается в создании списка всех "локальных" терминов, которые я хочу "сопоставить" со ссылками на термины онтологии. Я поместил этот список в электронную таблицу. Затем я использую Ontobee и OntoMaton, чтобы найти один термин онтологии для каждого локального термина. Обычно я могу найти его, немного поработав, но иногда я не могу. Мой третий шаг-решить, как включить каждый термин в онтологию моего приложения. Я использую четыре основных метода, каждый из которых описан в следующем разделе:

1. если есть всего несколько терминов из справочной онтологии, я добавлю MIREOT с помощью OntoFox
2. если я захочу использовать много разрывов из небольшой справочной онтологии, я импортирую все это с помощью Protégé
3. если в справочной онтологии много терминов или в справочной онтологии есть сложные логические аксиомы, но я не хочу импортировать все целиком, тогда я извлеку нужные мне термины с помощью OWLAPI
4. если нет ссылочного термина онтологии, то я буду защищать термин для своей онтологии приложения с помощью QTT или в Protég

Итак, это мои три шага:

1. составьте список местных терминов
2. поиск справочных терминов онтологии
3. решите, как импортировать каждый термин в онтологию моего приложения

Это [Google spreadsheet](https://docs.google.com/spreadsheets/d/16_CcUQc5bgAiJn2VALGp537uQzavInd5tyqzTbNvQLI/edit?usp=sharing) показывает список терминов из [data-before.csv](https://github.com/imbok-pro/obo-tutorial/blob/master/examples/data-before.csv), термины справочной онтологии, которые я тоже хочу сопоставить, и метод импорта, который я буду использовать. Он также показывает, как вы можете использовать Информационный плагин, чтобы упростить поиск.

Я сохранил копию электронной таблицы Google в [terms.csv](https://github.com/imbok-pro/obo-tutorial/blob/master/examples/terms.csv), и я написал несколько примеров кода для автоматического преобразования: [TermMapper](https://github.com/imbok-pro/obo-tutorial/blob/master/code/src/java/obo_tutorial/TermMapper.java). Если вы будете следовать инструкциям в [code/README.md](https://github.com/imbok-pro/obo-tutorial/blob/master/code/README.md), вы можете запустить его с помощью такой команды:

    cd examples
    java -jar ../bin/obo-tutorial.jar map terms.csv data-before.csv data-after.csv

Вы можете увидеть результат в [data-after.csv](https://github.com/imbok-pro/obo-tutorial/blob/master/examples/data-after.csv).


## Условия импорта

Как только вы найдете идеальный термин, как вы введете его в онтологию вашего приложения? Что делать, если вы не можете найти идеальный термин? В любом случае, существует целый ряд методов, которые вы можете использовать.


### Импорт Отдельных Терминов с помощью MIREOT

Использование термина онтологии означает использование его URI, но вы также захотите сохранить его метку, определение и другие аннотации. [[MIREOT: Минимальная информация для ссылки на внешний термин онтологии](http://content.iospress.com/articles/applied-ontology/ao087) - это руководство по тому, какую информацию следует включать при импорте термина. Мы даже используем "МИРЕОТ" как глагол: "Вы должны включить этот термин в свою онтологию".

Когда вы вводите термин, вам не нужно включать его родительские термины или логические аксиомы, но если вы этого не делаете, вам нужно быть осторожным. В качестве примера можно привести термин [Homo sapiens](http://purl.obolibrary.org/obo/NCBITaxon_9606) составляет около 29 узлов в таксономии NCBI. Если вы хотите использовать этот термин, вы, вероятно, не хотите импортировать всех его предков. Но вы должны убедиться, что все, что вы говорите об этом термине, по-прежнему верно! Вы могли бы поместить *Homo sapiens* в раздел [Млекопитающие](http://purl.obolibrary.org/obo/NCBITaxon_40674) в онтологии вашего приложения, что было бы правдой, даже если она не включает всю информацию, содержащуюся в таксономии NCBI. Не помещайте его под термин NCBI [Mus musculus](http://purl.obolibrary.org/obo/NCBITaxon_10090) потому что тогда ваше утверждение было бы ложным!


#### Импорт Наборов Терминов с помощью OntoFox

[[OntoFox](http://ontofox.hegroup.org) является удобным инструментом для извлечения терминов из онтологий OBO. Вы можете использовать форму на веб-сайте или создать входной файл, в котором указана конфигурация, и загрузить его. Файл конфигурации полезен, если вы хотите повторно запустить один и тот же импорт, например, для получения последних версий условий.

OntoFox - это бесплатный сервис, но у него ограниченные ресурсы.  Если вы не будете осторожны, вы можете запросить слишком много условий. Если это произойдет, сервер может зависнуть или выйти из строя, и вы не только не получите желаемого результата, но и другие люди не смогут пользоваться сервисом. Я рекомендую использовать OntoFox только для небольших наборов терминов, скажем, менее ста, включая промежуточные термины, обсуждаемые ниже.

Чтобы использовать OntoFox, вам нужно выбрать исходную онтологию, а затем предоставить два набора терминов, которые вы хотите импортировать: термины низкого уровня и термины верхнего уровня. Вам также придется выбрать, хотите ли вы включить *промежуточные* условия. У вас есть три варианта:

- `includeNoIntermediates`: будут включены только указанные вами условия
- `includeAllIntermediates`: все термины между низким и высшим уровнями будут включены
- `includeComputedIntermediates`: будет включен минимальный набор терминов, соединяющих нижний уровень с верхним уровнем

Другой вариант-включить всех детей данного семестра низкого уровня. Эти варианты могут поначалу немного сбить с толку, и стоит поэкспериментировать с несколькими различными комбинациями. Для больших онтологий, таких как таксономия NCBI, `includeNoIntermediates`, вероятно, является лучшим выбором. В противном случае `includeComputedIntermediates` обеспечивает хороший баланс.

Имейте в виду, что включение слишком большого количества промежуточных терминов может вызвать проблемы для сервера OntoFox. Когда вы экспериментируете с включением промежуточных звеньев, убедитесь, что существует всего несколько уровней иерархии между "низким" и "верхним", и начните с нескольких терминов, которые вы хотите импортировать.

OntoFox также предоставляет ряд опций для выбора аннотаций, которые вы хотите включить, и для сопоставления между наборами аннотаций. Хотя форма на веб-сайте позволяет извлекать термины только из одной онтологии за раз, в файле конфигурации вы можете указать несколько онтологий, каждая из которых содержит ряд терминов и другие параметры. Это еще одна причина научиться использовать [входные файлы конфигурации](http://ontofox.hegroup.org/tutorial/index.php#input_format).

В [ontofox.txt](https://github.com/imbok-pro/obo-tutorial/blob/master/examples/ontofox.txt) файл показывает, как выглядит входной файл OntoFox. Он состоит из четырех разделов, потому что мы импортируем из четырех онтологий: OBI, таксономия NCBI, MPATH и PATO. В нем перечислены термины нижнего и верхнего уровней, которые мы хотим импортировать из каждой справочной онтологии. В каждом разделе есть свое правило для выбора промежуточных элементов, но все они используют либо `includeAllAxiomsRecursively`, либо `includeAllAnnotationProperties`, чтобы получить полный набор аннотаций. В нем также показано, как использовать `subClassOf` для размещения импортированных терминов именно там, где вы их хотите.

На веб-сайте OntoFox вы можете "Загрузить входной файл" и с помощью `ontofox.txt` затем нажмите "Получить выходной файл OWL (RDF/XML)". Результирующий файл OWL имеет вид [ontofox.owl](https://github.com/imbok-pro/obo-tutorial/raw/master/examples/ontofox.owl).


### Импорт списков терминов с помощью Шаблонов быстрых терминов

Метод MIREOT и инструмент OntoFox являются правильным выбором для импорта ограниченного числа терминов из других онтологий. Для создания собственных терминов Protégé-хороший инструмент. Но если вы обнаружите, что создаете больше, чем несколько терминов с очень похожей структурой, вы можете пожелать, чтобы у вас была электронная таблица. В этом случае рассмотрите возможность использования [Шаблона быстрого определения (QTT)](https://content.iospress.com/articles/applied-ontology/ao086) метод.

QTT-это метод преобразования таблиц данных о терминах в формат OWL. В таблице у вас есть строка для каждого термина со столбцами для IRI, метки, определения и других примечаний. У вас также могут быть столбцы с IRIs для других терминов, которые имеют четко определенную связь с термином в этой строке, например родительский термин. Это входные данные для инструмента QTT, а выходные данные представляют собой представление OWL тех же данных, готовых для использования в вашей онтологии.

В [qtt.txt](https://github.com/imbok-pro/obo-tutorial/blob/master/examples/qtt.txt) файл представляет собой разделенную вкладками электронную таблицу с двумя локальными терминами, которые мы хотим определить для нашего примера: штаммы инбредных крыс и мышей. Эти термины, вероятно, должны быть определены в какой-то онтологии OBO, но мне не удалось их найти. Это соответствует нашим текущим целям-использовать их в качестве примера терминов онтологии приложений. Как вы можете видеть, я указал идентификатор термина в первом столбце, затем аннотации, такие как метка, определение и редактор. Я также дал ИРИ родительского термина.

Более старые версии Protégé поддерживали [MappingMaster](http://protege.cim3.net/cgi-bin/wiki.pl?MappingMaster) плагин для QTT, но он больше не поддерживается. Я Если вы знаете, как писать код Java и использовать OWLAPI, то вам будет просто написать свой собственный код QTT. Но самое простое решение-использовать Ontorat.


#### Импорт списков терминов с помощью Ontorat

[Ontorat](http://ontorat.hegroup.org) - это еще один инструмент из того же семейства, что и Ontobee и OntoFox. Как и в случае с OntoFox, вы можете использовать форму на веб-сайте или загрузить файл конфигурации. И, как и в случае с OntoFox, файл конфигурации имеет то преимущество, что он воспроизводим и предоставляет более мощные возможности за счет немного более крутой кривой обучения.

В [ontorat.txt](https://github.com/imbok-pro/obo-tutorial/blob/master/examples/ontorat.txt) файл показывает, как выглядит входной файл Ontorat. Мы используем разделы только для аннотаций и суперклассов, но есть и другие варианты. Прочитайте [учебное пособие](http://ontorat.hegroup.org/tutorial/index.php) чтобы получить все подробности, но основная операция состоит в том, чтобы создать новый класс для каждой строки в таблице QTT, затем создать аннотации и аксиомы, заменив каждое вхождение `{$columnX}` содержимым столбца X.

- одинарные кавычки-это понятные для человека названия терминов, и они должны быть определены с помощью IRI для этого термина
- двойные кавычки предназначены для строк аннотаций
- угловые скобки предназначены для радужной оболочки

На веб-сайте Ontorat вы можете "Загрузить файл настроек" с помощью этого файла, чтобы заполнить настройки, затем "Указать файл входных данных" с помощью "Загрузка файла" и использовать `qtt.txt`. Затем нажмите "Получить выходной файл OWL (RDF/XML)". Полученный файл OWL имеет вид [ontorat.owl](https://github.com/mbox-pro/robot-tutorial/raw/master/examples/ontorat.owl). Я изменил "IPI онтологии" для этого файла, используя Protégé, на что-то более разумное, чем по умолчанию.

### Импорт онтологий с помощью Protégé

Онтологии OBO являются частью сети связанных данных. Использование терминов из других онтологий означает создание ссылок на ресурсы в Интернете. Другой формой связывания является *импорт*: вы можете импортировать другую полную онтологию или файл OWL в свою собственную онтологию.

Для наших текущих целей существует два основных способа использования импорта OWL. Первый-это когда MIREOT просто недостаточно: вы не хотите импортировать только набор терминов из другой онтологии, вы хотите импортировать все целиком. Второй - использование результатов OntoFox и Ontorat. Эти инструменты генерируют файлы OWL. Используя файл конфигурации, вы можете запускать эти инструменты снова и снова для обновления условий, каждый раз создавая новые файлы OWL. Вы должны сохранить эти результаты в отдельных файлах OWL, а затем импортировать эти файлы в онтологию вашего приложения. Это четкое разделение позволяет легко обновлять импорт MIREOT и QTT.

Имейте в виду, что импорт может быть несколько непредсказуемым. Такие инструменты, как Protégé, сохранят локальную копию импортированных файлов, которая не всегда может быть актуальной. Если у вас и ваших сотрудников разные локальные копии импорта, вы не увидите точно таких же терминов и аксиом, что может привести ко всевозможной путанице!

Онтологии OBO имеют версии, обычно заданные по дате. Я рекомендую импортировать конкретную, устаревшую версию любой онтологии. Чтобы обновить его, просто измените ссылку на импорт на последнюю устаревшую версию. Это позволяет вам контролировать, когда производятся обновления. И если другой проект онтологии выпустит новую версию, которая что-то нарушит в вашей онтологии, вы сможете придерживаться более старой версии, пока проблема не будет устранена.

Для файлов OntoFox или Ontorat OWL просто используйте последние файлы OWL. Вы контролируете, когда вы обновляете эти файлы, поэтому не должно быть никаких проблем с несоответствием версий.

Еще одна вещь, которой следует остерегаться, - это `catalog.xml` (он же `catalog-v001.xml`) файл, используемый Protégé и OWL API. Это файлы конфигурации, автоматически созданные Protégé и содержащие информацию об импорте. Редактируя эти файлы, вы можете изменить, какие файлы Protégé использует для импорта, выполняя всевозможные перенаправления и замены. Это может быть очень удобно и *очень* запутанно. Хотя иногда это необходимо, будьте очень осторожны при использовании `catalog.xml` файлы. На этой странице объясняется [подробная информация об импорте OWL в Protégé](http://protegewiki.stanford.edu/wiki/How_Owl_2.0_Imports_Work).

Чтобы импортировать онтологию, сначала откройте онтологию приложения с помощью Protégé. На вкладке "Активная онтология" должна быть панель под названием "Импорт онтологий". Найдите "Прямой импорт" и нажмите на знак плюс рядом с ним. Это откроет "Мастер импорта онтологий", который предоставит вам широкий выбор вариантов. Вы можете импортировать данные либо из локального файла, либо из URI в Интернете. Для справочных онтологий я предлагаю использовать URI для устаревшей версии. Протеже будет периодически получать новую копию файла, поэтому не забывайте по возможности использовать версию с датой. Для результатов OntoFox и Ontorat я говорю мастеру импорта использовать локальный файл.

Вот скриншот из последней бета-версии Protégé 5, импортирующей версию OBI 2014-08-18.

![Protégé import screenshot](../images/import.png)


### Извлечение модулей онтологии с помощью OWLAPI

Иногда требуется импортировать слишком много терминов для OntoFox, но целевая онтология слишком велика, чтобы импортировать ее всю. Есть инструмент, который вы можете использовать в этом среднем случае: [OWLAPI](http://owlapi.sourceforge.net)'ы [SyntacticLocalityModuleExtractor](http://owlapi.sourceforge.net/javadoc/index.html?uk/ac/manchester/cs/owlapi/modularity/SyntacticLocalityModuleExtractor.html). Учитывая онтологию и набор терминов для извлечения, он создаст "модуль" только с этими терминами и терминами, от которых они зависят. Эти зависимости рекурсивны, поэтому инструмент возьмет ваш список терминов, добавит все термины, от которых они зависят, затем добавит все термины, от которых зависят эти зависимости, и так далее, пока не найдет закрытый набор терминов. Полученную онтологию можно сохранить в файле OWL и импортировать в онтологию приложения.

Использование этой техники требует использования OWLAPI, что означает написание некоторого кода Java. Там нет веб-службы, которая могла бы сделать это за вас, но я привел несколько примеров кода.

Если онтология содержит много логических аксиом, извлеченный модуль все равно может быть слишком большим. Чтобы уменьшить количество логических аксиом, мы можем использовать одну из многих команд, предоставляемых [owltools](https://github.com/owlcollab/owltools). Команда `--make-subset-by-properties` берет список свойств объекта OWL для сохранения и удаляет все остальные.

Если вы хотите попробовать это, скачайте последнюю версию [owltools-runner-all.jar](http://build.berkeleybop.org/job/owltools/lastSuccessfulBuild/artifact/OWLTools-Runner/bin/owltools-runner-all.jar), или [постройте его сами](https://github.com/owlcollab/owltools), и поместите файл в каталог `bin` этого руководства.

Давайте посмотрим на это в действии. Первая загрузка [Uberon](purl.obolibrary.org/obo/uberon.owl) (это около 60 МБ) в каталог `examples`, затем `cd` в каталог `examples`. Вторая команда будет использовать owltools, чтобы сохранить только `part_of` и `has_part` от Uberon. Третья команда извлечет только список терминов, которые мы хотим:

    cd examples
    java -jar ../bin/owltools-runner-all.jar uberon.owl --make-subset-by-properties BFO:0000050 BFO:0000051 -o uberon-subset.owl
    java -jar ../bin/obo-tutorial.jar extract \
      uberon-subset.owl \
      uberon-terms.txt \
      uberon-module.owl \
      "https://github.com/imbok-pro/obo-tutorial/raw/master/examples/uberon-module.owl"

В результате получается [luberon-module.owl](https://github.com/mbox-pro/robot-tutorial/raw/master/examples/uberon-module.owl) файл со всеми условиями, перечисленными в [uberon-terms.txt](https://github.com/imbok-pro/obo-tutorial/blob/master/examples/uberon-terms.txt) и все их зависимости `part_of/has_part`. Чтобы узнать больше, смотрите:

- краткий официальный пример (PDF) [Примерное руководство по API OWL](http://owlapi.sourceforge.net/download 2011_tutorial.pdf)
- пример кода: [Extractor.java](https://github.com/imbok-pro/obo-tutorial/blob/master/code/src/java/obo_tutorial/Extractor.java)

## Собирая все это вместе

Сначала мы увидели, как найти термины справочной онтологии и оценить их. Затем мы увидели, как создать таблицу "сопоставления" для всех наших терминов. И мы только что рассмотрели четыре метода импорта терминов справочной онтологии в нашу онтологию приложения. Последний шаг - собрать все это вместе и завершить онтологию нашего приложения.

1. Откройте новую онтологию
2. Изменить его "Ontology IRI" на <https://github.com/imbok-pro/obo-tutorial/raw/master/examples/application.owl>
3. Импортируйте три файла OWL:
    - ontofox.owl
    - ontorat.owl
    - uberon-module.owl
4. Внесите коррективы: добавьте термины, добавьте примечания, *тщательно* отрегулируйте иерархию
5. Сохраните онтологию в `application.owl`

Или пропустите эти шаги и просто посмотрите на результат [application.owl](https://github.com/mbox-pro/robot-tutorial/raw/master/examples/application.owl) файл, который я создал. Результат включает в себя все термины, перечисленные в нашем файле `terms.csv`, а также нужные нам зависимости. Я также внес коррективы, чтобы все соответствовало "сущности" BFO, добавив утверждения `subClassOf` здесь и там.

Одна онтология приложения может поддерживать множество подобных проектов. В [следующем разделе](https://github.com/imbok-pro/obo-tutorial/blob/master/docs/processing-data.md) мы увидим, как подключить данные в запущенном примере к онтологии приложения, чтобы в полной мере воспользоваться ее преимуществами.